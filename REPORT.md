# WRITTEN REPORT

We initially set out with the Bitcoin OTC dataset to create a tool that will rank users “trustworthiness” based on the ratings that other users have made. The data set is a directed graph where the nodes represent the users and the edges represent the rating of their transaction.The idea is that given the ID of a user and our code will return information on the user’s general trustworthiness. Another thing that we planned was the ability to input two separate user IDs to receive the shortest path between them. This is both in terms of number of nodes as well as the shortest “path of trust” between them.
 We implemented BFS to traverse through the dataset and to get the shortest path between two users. We implemented three functions that utilize the BFS algorithm. Our first method, BFSSearch takes in two nodes and finds the shortest path from the first to the second. This path is based solely on the number of edges between them and pays no attention to the weights. Our second method, BFSTraversal takes in one user and traverses one connected component of the graph to produce a vector of ints that can be backtracked to find the shortest path to any node from the provided start node. Finally, our comprehensiveBFSTraversal runs multiple BFSTraversals on any disconnected components of the graph until every node is visited. The runtime for our BFS is O(V + E), where V is the number of vertices and E is the number of edges.

As BFS cannot be used to find shortest paths based on edge weights, we implemented Dijkstra’s Algorithm to find the shortest paths between nodes to estimate the trust relation between two users who have not rated each other. Originally the data set’s edges represent the rating of legitimacy and trust between users from the range [-10, 10], but while implementing Dijkstra’s Algorithm, we realized Dijkstra only works with positive weights. Our solution to this is to offset the weights by subtracting the current weight from 10. By doing this, it maps the lowest rating to the highest distance (our untrustworthiness metric). For example: -10 maps to 20, 0 maps to 10, and 10 maps to 0. The total runtime for Dijkstra’s is O(|E| + |V|log(|V|)), where V is the number of vertices and E is the number of edges.

Our final product, the SCC algorithm, reads the graph and outputs a vector of node indexes that correspond to separate strongly connected components that exist. Our implementation works by using the property of  a common ancestor that exists within a connected component and a stack invariant that removes found components from common ancestor checks.Through the process of implementing the SCC algorithm we were able to discover the general graph structure which underlined our Bitcoin OTC. There was one very large strongly connected component and multiple smaller 



connected components that were disjoint from the largest one. While implementing the graph we were confronted by several issues, including but not limited to complications with the size of our id vector, having a find operation that would run on O(1) time in both directions (from our real user ids to the newly constructed lowlink values), and storing the values corresponding to a certain call of our recursive DFS. Solving these issues were time consuming but we were able to construct unique solutions to the challenges we encountered. One solution included creating a pseudo one-to-one mapping using std::maps which allowed us to simultaneously be able to do our lowlink checks in the appropriate function call and directly switch between the two index values.

Certain evaluations we would like to make as a group include the optimization strategies we conducted after successfully implementing each algorithm. A major priority in these improvements was the time complexity of each algorithm. For example when implementing SCC, our group specifically selected Tarjan’s algorithm as it solely requires one DFS Traversal in contrast with Kosaraju’s which requires three. This often came at some cost in space complexity, for example we created a separate vector called “incomingEdges”, which is essentially a transpose of the “outgoingEdges” class. This was done so that all “neighbor” searches could be done in O(1) time.


The implementation of a test suite using catch allowed us to rigorously test our algorithms before running them on the bitcoin otc data set. We methodically constructed our tests to determine possible errors in extreme/erroneous values while confirming that the algorithms work as intended.	These can be found in the test folder and provide evidence for the validity of our code.


